import logging
from sensor.sensor import SensorEncoder
from msp.response_encoder import MspResponseEncoder

from msp.request_decoder import MspRequestDecoder, MspError
from sport.frame import FrameId, FrameEncoder
from sport.physical_id import PhysicalId
from util.buffer import WriteBuffer
from util.loop import loop

_logger = logging.getLogger("exchange")


class SportCoordinator:
    _DEFAULT_TRANSMIT_ID = PhysicalId.ID27
    _DEFAULT_RECEIVE_ID = PhysicalId.ID13

    def __init__(self, pumper, transmit_id=_DEFAULT_TRANSMIT_ID, receive_id=_DEFAULT_RECEIVE_ID):
        pumper.add_publisher(transmit_id, self._write_transmit_frame)
        pumper.add_subscriber(receive_id, self._receive)
        self._msp_request_decoder = MspRequestDecoder()
        self._msp_response_encoder = MspResponseEncoder()
        self._send_msp_response = False
        self._frame_encoder = FrameEncoder()
        self._sensors = None
        self._sensor_loop = None
        self._commands = {}

    def set_sensors(self, sensors):
        self._sensors = sensors
        self._sensor_loop = loop(len(sensors))

    def set_commands(self, commands):
        self._commands = commands

    def _write_transmit_frame(self, frame):
        if self._send_msp_response:
            self._write_msp_response_frame(frame)
            return True
        elif self._sensors:
            self._write_sensor_frame(frame)
            return True
        return False

    def _write_sensor_frame(self, frame):
        sensor = self._sensors[next(self._sensor_loop)]
        SensorEncoder.encode(sensor, frame)

    def _write_msp_response_frame(self, frame):
        self._send_msp_response = self._msp_response_encoder.encode(frame)

    def _receive(self, frame):
        if frame.get_id() != FrameId.MSP_CLIENT:
            _logger.warning("ignoring frame with ID %02X", frame.get_id())
            return

        if self._send_msp_response:
            _logger.warning("MSP frame received while still sending previous response - discarding old response")
            self._send_msp_response = False

        result = self._msp_request_decoder.decode(frame.payload)

        if not result:
            return

        # A complete MSP request has been received - now to create the response...
        self._send_msp_response = True

        # There was something basic wrong with the request - create an error response.
        if result.error is not None:
            self._msp_response_encoder.set_error(result.error, result.command_id)
            return

        command = self._commands.get(result.command_id)

        # We don't know how to handle this command.
        if command is None:
            _logger.error("no handler registered for command %d", result.command_id)
            self._msp_response_encoder.set_error(MspError.ERROR, result.command_id)
            return

        def response_writer(response_buffer):
            # TODO: perhaps rename `result.payload` to `result.request`.
            command.handle_request(result.payload, response_buffer)

        # TODO: maybe move write_view logic in set_command up to this level (where it can be called `response_buffer`
        #  and be the owner of the underlying memory). Then you'll still need a separate one byte bytearray buffer
        #  internal to MspResponseEncoder for error responses.

        # Create a response to the command, including the payload generated by the command handler.
        self._msp_response_encoder.set_command(command.id, response_writer)
